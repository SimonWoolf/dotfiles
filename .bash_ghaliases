cos() {
	TARGET="shell"

	read -r -d '' __USAGE <<-EOF
	Uses Claude 4.5 via \`llm\` to suggest a command based on a natural language description of the desired output effort.
	Supports executing suggested commands if applicable.

	USAGE
	  $FUNCNAME [flags] <prompt>

	FLAGS
	  -h, --help               Display help usage
	  -t, --target target      Target for suggestion; must be shell, gh, git
	                           default: "$TARGET"

	EXAMPLES

	- Guided experience
	  $ $FUNCNAME

	- Git use cases
	  $ $FUNCNAME -t git "Undo the most recent local commits"
	  $ $FUNCNAME -t git "Clean up local branches"
	  $ $FUNCNAME -t git "Setup LFS for images"

	- Working with the GitHub CLI in the terminal
	  $ $FUNCNAME -t gh "Create pull request"
	  $ $FUNCNAME -t gh "List pull requests waiting for my review"
	  $ $FUNCNAME -t gh "Summarize work I have done in issues and pull requests for promotion"

	- General use cases
	  $ $FUNCNAME "Kill processes holding onto deleted files"
	  $ $FUNCNAME "Test whether there are SSL/TLS issues with github.com"
	  $ $FUNCNAME "Convert SVG to PNG and resize"
	  $ $FUNCNAME "Convert MOV to animated PNG"
	EOF

	local OPT OPTARG OPTIND
	while getopts "ht:-:" OPT; do
		if [ "$OPT" = "-" ]; then     # long option: reformulate OPT and OPTARG
			OPT="${OPTARG%%=*}"       # extract long option name
			OPTARG="${OPTARG#"$OPT"}" # extract long option argument (may be empty)
			OPTARG="${OPTARG#=}"      # if long option argument, remove assigning `=`
		fi

		case "$OPT" in
			help | h)
				echo "$__USAGE"
				return 0
				;;

			target | t)
				TARGET="$OPTARG"
				;;
		esac
	done

	# shift so that $@, $1, etc. refer to the non-option arguments
	shift "$((OPTIND-1))"

	TMPFILE="$(mktemp -t gh-copilotXXX)"
	trap 'rm -f "$TMPFILE"' EXIT

	# Build the prompt for llm
	local PROMPT="You are a command-line expert. The user wants a $TARGET command to accomplish the following task.

Target context: $TARGET
Task: $@

Respond with ONLY the command itself, with no explanation, no markdown formatting, no code blocks, and no additional text. Output exactly what should be executed in the terminal."

	FIXED_CMD=$(llm "$PROMPT")
	local EXIT_CODE=$?

	if [ $EXIT_CODE -ne 0 ]; then
		echo "Error: Failed to get command suggestion from llm" >&2
		return 1
	fi

	# Remove any potential markdown code blocks or extra whitespace
	FIXED_CMD=$(echo "$FIXED_CMD" | sed -e 's/^```[a-z]*$//' -e 's/^```$//' -e 's/^`//' -e 's/`$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

	if [ -z "$FIXED_CMD" ]; then
		echo "Error: No command suggestion received" >&2
		return 1
	fi

	echo "Suggested command:"
	echo "  $FIXED_CMD"
	echo
	read -p "Execute this command? (y/N) " -n 1 -r
	echo

	if [[ $REPLY =~ ^[Yy]$ ]]; then
		echo "$FIXED_CMD" > "$TMPFILE"
		history -s $(history 1 | cut -d' ' -f4-); history -s "$FIXED_CMD"
		eval "$FIXED_CMD"
	fi
}

coe() {
	read -r -d '' __USAGE <<-EOF
	Uses Claude 4.5 via \`llm\` to explain a given input command in natural language.

	USAGE
	  $FUNCNAME [flags] <command>

	FLAGS
	  -h, --help    Display help usage

	EXAMPLES

	# View disk usage, sorted by size
	$ $FUNCNAME 'du -sh | sort -h'

	# View git repository history as text graphical representation
	$ $FUNCNAME 'git log --oneline --graph --decorate --all'

	# Remove binary objects larger than 50 megabytes from git history
	$ $FUNCNAME 'bfg --strip-blobs-bigger-than 50M'
	EOF

	local OPT OPTARG OPTIND
	while getopts "h-:" OPT; do
		if [ "$OPT" = "-" ]; then     # long option: reformulate OPT and OPTARG
			OPT="${OPTARG%%=*}"       # extract long option name
			OPTARG="${OPTARG#"$OPT"}" # extract long option argument (may be empty)
			OPTARG="${OPTARG#=}"      # if long option argument, remove assigning `=`
		fi

		case "$OPT" in
			help | h)
				echo "$__USAGE"
				return 0
				;;
		esac
	done

	# shift so that $@, $1, etc. refer to the non-option arguments
	shift "$((OPTIND-1))"

	if [ -z "$*" ]; then
		echo "Error: No command provided to explain" >&2
		echo "$__USAGE"
		return 1
	fi

	# Build the prompt for llm
	local PROMPT="You are a command-line expert. Please explain the following command in clear, natural language. Describe what it does, what each part means, and any important notes about its usage.

Command: $*

Provide a helpful explanation suitable for someone learning about this command."

	llm "$PROMPT"
}
